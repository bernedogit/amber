File Formats and Encodings
==========================

This file describes the encodings and file formats used by the library and
amber. The description starts with the bigger entities and proceeds down to
the function calls that are used to create the parts of the file. For
instance it refers to using `scrypt_blake2b()`. This means that we would use
this function (documented in *symmetric.hpp*) to generate this part. The
actual documentation for this function is in the *symmetric.hpp*. This file
just uses it as a building block.


Encrypt multi function
----------------------

Each packet is encrypted by the `encrypt_multi()` function. This function
performs the encryption in a way similar to `secretbox()` in NaCl. The
function takes as input the plain text, the ChaCha20 state corresponding to
the encryption key, the nonce and an array of ChaCha20 states corresponding
to the authentication keys. It generates the corresponding ciphertext,
including the authentication tags.

ChaCha20 creates a block of 64 bytes based on the key, the 64 bit nonce and a
64 bit block counter. This is generated by `chacha20 (key, nonce, bn)`.

To create the ciphertext we first generate a stream of ChaCha20 blocks, each
of 64 bytes, starting with the block number 1. We xor this stream with the
input to produce the first part of the ciphertext. If the length of the plain
text is *mlen*, then the first *mlen* bytes of the ciphertext contain the
result of xoring the plain text with the ChaCha20 stream. The key used to
create this stream is the encryption key Ke.

The `encrypt_many()` also takes the array of authentication keys Ka, with
each element of this array Ka[i] being the key used to authencate the message
for user i. The ciphertext includes the xored message mentioned above and a
sequence of 16 byte tags, one per receiver. To compute the tag for receiver
i, we derive the poly1305 key as follows: `chacha20 (Ka[i], nonce,
uint64(-i))`. The first 32 bytes of this block are then used as the poly1305
key and then poly1305 is used to create the corresponding 16 byte tag. Note
that even if the authentication keys are repeated the resulting tag will not
be the same because we generate the key using a different block for each key.
The selected blocks are 0 for the first block and the last blocks of the
possible 2⁶⁴ blocks for the other recipients. Given that we are not expected
to use that many blocks, we will never use for encryption the blocks intended
for authentication. Note that we already reach the 2⁶⁴ byte limit when we use
2⁵⁸ blocks.

For instance if there are 4 recipients the blocks selected as the key for
Poly1305 will be `chacha20(ka[0], nonce, 0)`, `chacha20(ka[1], nonce, 2⁶⁴ -
1)`, `chacha20(ka[2], nonce, 2⁶⁴ - 2)` and `chacha20(ka[3], nonce, 2⁶⁴ - 3)`.
If we only have one single recipient and we select the same key for
encryption and authentication then we fall back to the normal ChaChaPoly
AEAD as defined in the RFC. Therefore we can reuse `encrypt_many()` to
implement the RFC version by just passing the same key for encryption and
authentication. Note also that even if we repeat the authentication keys the
actual key used for Poly1305 will be different.

The `decrypt_many()` computes the authentication tag in the same way using
the key provided for the decryption and checks it against the expected tag
position. If the found tag is identical to the expected tag then it proceeds
to xor the ciphertext in the same way as `encrypt_many()` to obtain the plain
text.


The `encrypt_one()` and `decrypt_one()` are just shorthands for using the
encryption key as authentication key.



Encryption format
-----------------

The format of an encrypted file is a header followed by a sequence of 
packets. The header uses a fixed format. The packets in the sequence are not 
delimited in any way and without the decryption key it is not even possible 
to separate them.

There is one header type for password based encryption and another one for
public key encryption. The format of the packets that follow the header is
common to both types of encryption.


Symmetric encryption header
---------------------------

The first 32 bytes of the header are the salt. It will be used as the salt
for the key derivation from the password. This salt must be generated using
random bytes.

The decrypting program shall process the decryption password using the 
`scrypt_blake2b()` function using the salt. This will produce the key k1. The 
`scrypt_blake2b()` function takes a password, a salt, a *shifts* parameter 
(which is equal to log₂(N), with N as defined in the Scrypt paper) and 
produces a key. The salt are the first 32 bytes of the symmetric header. The 
shifts parameter is not explicitely encoded. See below for how it is used.

After the salt there is a block of 24 bytes that contains the encrypted value
of the block size and block filler.

The decrypting program shall decrypt the 24 bytes containing the encrypted
block size and filler by using the function `decrypt_one()` using the key k1.
The nonce will be 0. After decrypting the nonce shall be incremented by one.
The plain text are 8 bytes that shall be interpreted as follows. The first 4
bytes are interpreted as a little endian integer that contains the block
size. The next 4 bytes are interpreted as a little endian integer that
contains the block filler size.

We start with nonce set to zero because the actual key is based on the
password and the 32 byte random salt. This ensures that they key will be
unique and we can just start with nonce set to zero because the likelihood of
reusing the same key is negligible. DJB created XSalsa20 to work with fixed
keys and random nonces. His random nonce is 24 bytes long. We use a random 32
byte salt to make sure that the key will be unique. Thus there is no need to
also randomize the nonce.

The `scrypt_blake2b()` takes a *shifts* parameter. It is *shifts=log₂(N)*,
where N is the parameter named N in the Scrypt paper. The memory space
required by Scrypt is 2^shifts KiB. The running time is proportional to the
memory required. The default value is 14 (16 MiB of memory).

The shifts parameter required for scrypt is not included in the header. The
reason is that the header must be indistinguishable from random bytes. In
order to decrypt the header we start with a low value of the shifts
parameter, derive a key and try the key on the 24 bytes of encrypted block
size and block filler. If the decryption fails then we increment the value of
shifts and try again. If we reach a limit of the maximum allowable value for
the shifts parameter then this means that the supplied password is wrong.
Using this scheme we avoid putting any plain data in the header but increase
the work required by the decoder. However this increase is less than choosing
the next value of shifts. An advantage of this method is that for failed
passwords the attacker needs to try the highest possible values of shifts
too, making his work more difficult.

After processing the header we have the block size, the block filler size,
the nonce and the key k1. They are all that is required to decrypt the
sequence of packets that follows the header.

The packets that follow the header are encrypted using the `encrypt_one()`
function. This function uses the same key for encryption and for
authentication.



Public key encryption header
----------------------------

The public key encryption header can be described as a sequence of Noise X
patterns, followed by a single encrypted block containing the block
parameters.

To create the public key header we must first create an ephemeral symmetric
key, `c`. We store the number of recipients into a single byte and append
this single byte to `c` to create the 33 byte string `cn`. This limits the
format to 255 recipients. If you have more recipients for your "secret"
message don't bother using encryption: you may as well publish it.

For each recipient we create the Noise X message using `cn` as the payload.
The encryption key used for the body packets will be the ephemeral symmetric
key and the authentication key used for this receiver will be the key
produced by the Noise protocol. Note that each of these Noise X messages
contains exactly 129 bytes: 32 for the ephemeral X25519 key, 48 for the
encrypted static key of the sender and 49 for the encrypted payload. Instead
of using the public key of the ephemeral we store its Elligator2
representative. This ensures that the messages are indistinguishable from
random.

After all the Noise X messages have been written we use `encrypt_many()` to
encrypt the block size, the filler size and the size of the additional
information block. All numbers are encoded as four byte little endian
sequences. The resulting 12 byte plaintext is encrypted to produce a
ciphertext of 12 + n*16 bytes, where n is the number of recipients. The block
size is the size of chunks of plaintext that will be processed. The filler
size is the amount of bytes within each block of size `block_size` that are
just padding bytes. These padding bytes are always at the beginning of each
block. The size of the additional information is the plaintext size of
additional information. If this size is not zero then there is an encrypted
block that contains the additional information. There is no additional
information defined yet, but this mechanism is there to allow for future
expansion. When reading the reader will read and decrypt the additional
information block if present.

When reading, the receiver will try to process each 129 byte block as a Noise
X message using its private key. This process will be repeated until we have
tried 255 blocks or we have found one block that we can decrypt with our key.
If we try all 255 blocks and none could be decrypted (or we reached the end
of the file before) then this file has not been encrypted for our key and we
stop. If one of the blocks could be successfully processed then we get as
payload the `cn` string. The first 32 bytes of this string are the symmetric
key. The last byte tells us how many recipients are in total. We skip the
remaining unread 129-byte blocks. Then we use `decrypt_many()` to decrypt the
block size, the filler size parameters and the information block size. The
decryption key will be the symmetric key and the authentication key will be
the one produced by the Noise protocol.

Given that each authentication key is created using the Noise X pattern each
resulting authentication key will be different. The `encrypt_many()` still
offers the protection against repeated authentication keys because it could
be used for other purposes.


Packet sequence
---------------

After either the symmetric header or the public key header we have a sequence
of packets. Each packet has *block_size* bytes of plaintext, where
*block_size* has been obtained by decrypting the header. The last packet may
have fewer bytes. After encryption each packet will have `block_size +
16*nrx` bytes where *nrx* is the number of recipients. For symmetric
encryption *nrx* is 1. There is no separation between two consecutive
packets: without the decryption key Eve cannot figure out where the packet
boundaries are because the *block_size* value is transmitted in encrypted
form. The decryption program just reads each packet knowing that each packet
has `block_size + 16*nrx` bytes. The last one may have fewer bytes. We can
also seek to any particular packet. For instance the packet number *i* is
located at the byte offset `header_size + i * (block_size + 16*nrx)`. This is
what provides the random access capabilities. We can encrypt and decrypt each
packet independently from each other. The nonce for the packet number *i* is
`base_nonce + i`.

Each packet is encrypted using `encrypt_multi()`. The key used is *k1* in the
case of the symmetric encryption. The key used for a public key encryption is
the ephemeral symmetric key. The nonce is incremented for each packet. The
authentication keys are the ones computed above for the case of public key
encryption. For the symmetric encryption the authentication key is just *k1*.

Within each packet the plain text is made of two parts. There are always
*block_filler* bytes of filler bytes at the beginning of the plain text. The
value of *block_filler* is stored in encrypted form in the header. The filler
bytes are random bytes that are generated for each packet. No two packets
share the same filler bytes. After the filler bytes come the real payload
bytes. The number of payload bytes is `block_size - block_filler` bytes for
all packets except the last one. The last one may have between 0 and
`block_size - block_filler - 1` bytes of payload. When decrypting each packet
we decrypt the ciphertext and then discard the first *block_filler* bytes of
the plain text.

The purpose of the block filler bytes is to decouple the size of the
encrypted file from the size of the plaintext. By default the value of
*block_filler* is chosen at random and it provides some protection against
traffic analysis.

When generating the sequence of packets we just encrypt full packets until we
run out of input. The last packet that is generated must have fewer than
`block_size - block_filler` bytes of payload because this signals the end of
the stream. If the last block of data before the end of input had exactly
`block_size - block_filler` bytes of payload then we generate an extra packet
with just 0 bytes of payload. This packet will only have filler bytes.

The `encrypt_many()` and `decrypt_many()` functions take additional
authentication data that is authenticated by the authentication tag together
with the ciphertext. The additional authenticated data is just a single byte
for each packet. The first packet of the sequence has an additional data byte
with value 1. The last packet of the sequence has an additional data byte
with value 3. All other packets have an additional data byte with value 2. If
there is just one single packet then it will have the additional data byte
with value 3. Whenever we encrypt the last packet (additional data byte with
value == 3) the nonce used is increased by *ndelta*. This gives an additional
check of the last packet.

The additional data byte is authenticated together with the ciphertext. The
purpose of this additional data byte is to detect truncation at the end or at
the start of the packet sequence. An attacker cannot modify a packet without
this being detected by the authentication tag. However the attacker could try
to alter the sequence of packets, even if the packets themselves cannot be
altered. We use consecutive nonces for each packet. If we rearrange the order
of the packets the authentication will fail because the nonces will be wrong.

However the attacker could try to remove packets from either the beginning or
the end of the packet sequence. The packets remaining in the stream would
seem to be in the correct order using consecutive nonces. We protect against
such attacks by using the authenticated additional data and the special
sequence of nonces.

The first packet has a byte of authenticated data with the value 1. The
middle packets have an authenticated byte with value 2 and the last packet
has an authenticated byte with value 3. The starting nonce is fixed by the
format of the data stream. Subsequent packets are encrypted by incrementing
the nonce by one for each packet. The last packet gets an additional bump in
the nonce of *ndelta*.

If the attacker removes packets from the start of the sequence this will be
detected due to the nonce not being the correct one and by the authentication
byte not being 1 for the first packet. If the attacker removes packets from
the end of the sequence this will be detected by the authentication byte not
being 3 for the last packet and the nonce of the last packet. The nonce of
the last packet is the nonce that would correspond according to the sequence
of packets but incremented by ndelta. ndelta is 0x8000000000000000. This is
an uint64_t with the highest bit set. This means that the last nonce will not
have been used in the stream if there have been less than 2⁶³ packets in the
stream. The streambuf signals an error if you try to write more than 2⁶³
packets (2⁶⁹ bytes).

Both the use of deterministic nonces for the first and last packet and the use
of the authenticated data ensure that truncations will be detected.

Note that the additional authenticated byte is not stored anywhere in the
message. It is computed by both the sender and the receiver.


Deniable encryption
-------------------

As stated above the filler bytes within each packet are generated randomly
for each packet. When implementing deniable encryption the filler bytes are
themselves the ciphertext corresponding to the second plain text. To create
the filler bytes we use either a second password or a second public key. The
outer encryption uses the normal procedures shown above. The inner encryption
encrypts blocks of `block_filler - 16` bytes with `encrypt_one()` to generate
*block_filler* bytes of ciphertext. The nonce used for the inner encryption
is made of the first 16 bytes of the key used for the outer encryption
appended with the 8 bytes of the nonce64 used for the outer encryption. The
first eight bytes of the plain text encrypted in the filler bytes of the
first packet are read as a little endian 64 bit integer that gives the size
of the second plain text. The decryption process will read this amount of
data from the decrypted bytes and it will discard the rest.






Wire Format for Keys and Archives
=================================

The formats used for key storage and archive storage are binary formats that
use the wire format of the Google Protocol Buffers. The wire format is a
sequence of tag-length-value triplets. Each triplet starts with a tag and is
optionally followed by a length and a value. The tags and lengths are encoded
as little endian base 128, LEB128, variable length integers.

The LEB128 encoding is defined as a sequence of bytes that are interpreted as
an unsigned integer. Each byte belonging to the sequence has its most
significant bit set except the last byte of the sequence which has its most
significant bit cleared. The remaining 7 bits of each byte are interpreted in
little endian order as the bits of the unsigned integer. If there is a single
byte then it has its most significant bit cleared.

LEB128 needs just one byte to encode values between 0 and 127. The number of
bytes required to encode a value increases with the value itself. Therefore we
should strive to use small integer values as tags to minimize the space that
they need.

Each triplet starts with a tag. The tag is an integer encoded in LEB128
format. The lowest 3 bits of the tag encode the "wire type". The remaining
bits of the tag encode the tag id. The tag id is what distinguishes different
triplets from each other.

The wire type provides information about the rest of the triplet. The wire
type values have been defined by Google:

 - a wire type of 0 signals that there is no length field and the tag is
   followed by a single value encoded as a LEB128. This is the varint wire
   type.

 - a wire type of 1 signals that there is no length field. The tag is followed
   by a value that takes 8 bytes. The application shall interpret it as a
   little endian integer or little endian floating point double. This is the
   fixed64 wire type.

 - a wire type of 2 signals that there is a length field encoded as a LEB128.
   After the length field the payload bytes follow. The length field contains
   the number of bytes that follow the tag and the length fields. This the
   length_val wire type.

 - a wire type of 3 signals the start of a group. There is no length field
   and no value in this triplet. Instead the application is supposed to keep
   processing triplets until a tag is found with the group-end wire type and
   the same tag id. The intention is to mark the start of group of data by
   using the wire type 3 and end the same group of data with the group end
   tag. The start and end of group tags bracket the triplets that belong to
   the same group. This is the group_start wire type.

 - a wire type of 4 signals the end of a group. There is no length field or
   value field in this triplet. When this tag is found it means that we have
   reached the end of the group that has the tag id. This is the group end
   wire type.

 - a wire type of 5 signals that there is no length field. The tag is followed
   by a value that takes 4 bytes. The application shall interpret it as a
   little endian integer or little endian single precision float. This is the
   fixed32 wire type.

 - we extend this list with the wire type 6, which is the same as 2, but also
   signals that this triplet contains embedded triplets within its contents.
   Using a separate wire type allows us to have debugging tools that produce
   a hierarchical dump of the file without actually knowing what is inside.

A triplet may contain further triplets in its value field. Such a triplet
would have the wire type of 6 and the application would just interpret its
value as a sequence of triplets.

The wire format has the following advantages:

 - It is very compact. If the tags have low values the overhead per each tag
   can be as low as just one byte.

 - It is backwards and forwards compatible. The wire type includes just
   enough information to allow skipping of triplets that are not understood.
   We can add new triplet types and existing applications will just skip
   them. This applies to the top level triplets but also to triplets embedded
   into other triplets.

An example of the advantages is in the format used for the archive files.
There is a central directory at the end of the file. The directory is just a
sequence of triplets, one per file included in the archive. Within each file
triplet there are triplets that describe the properties of the file. It is
possible to add a new triplet type to describe additional properties. The
existing programs will just skip this new triplet and process the ones that
they know about.


When describing the triplets we use the following notation:

	enum Wire_type {
		varint      = 0,    // The following value is a ULEB128/ZLEB128.
		fixed64     = 1,    // The following value are 8 bytes.
		length_val  = 2,    // uleb128 encoded length, followed by bytes[length].
		group_start = 3,    // Start of a group.
		group_end   = 4,    // End of a group.
		fixed32     = 5,    // The following value are 4 bytes.
		group_len   = 6     // uleb128 encoded length, followed by
							// bytes[length]. The content is a sequence of
							// triplets.
	};

	constexpr int wiretype(unsigned x) { return x & 7; }
	constexpr uint32_t maketag(uint32_t id, Wire_type wt) { return (id << 3)|wt; }

When storing strings it is assumed that the character set used is UTF-8.


Key storage format
------------------

The keys are stored as a sequence of group_len items with id set to
`top_key`. Within each key there are several types of triplets. They can
appear in any order.

 - The triplet maketag(key_pub, length_val) contains the 32-byte public part
   of the key.

 - The triplet maketag(key_sec, length_val) contains the 32-byte secret part
   of the key. This triplet is optional and is present only if we  have the
   secret part.

 - The triplet maketag(key_name, length_val) contains the name of owner of
   the key. The program and library does not care about the structure of the
   name but by convention it should be a name followed by an email address.

 - The triplet maketag(key_alias, length_val) contains a string with aliases
   for the owner.

 - The triplet maketag(key_time, varint) contains the time in seconds since
   the epoch (the value of time_t) when the key was created.

 - The triplet maketag(key_master, varint) contains a boolean. If it is zero
   then the key is just a working key. If it is not zero then the key is a
   master key.

 - The triplet maketag(key_self_sig, length_val) contains the 64 bytes of the
   signature by this key of its public key, the name and the creation time.

 - The triplet maketag(key_sig, group_len) contains the signatures attached
   to the key. There may be several of these triplets, each containing a
   different signature. Each of these triplets contains other triplets:

	- maketag(key_sig_signer, length_val) contains the 32 bytes of the public
	  key that signs this key.

	- maketag(key_sig_signature, length_val) contains the 64 bytes of the
	  signature by  the owner of the key_sig_signer key. The signed parts are
	  the public key, the name and the creation time.

If the key file is encrypted, then the previous description refers to the
plain text of the decrypted file. The routines that read the keys just read
from a std::istream. In the case of an encrypted file the decrypting ifstream
is passed instead of a std::ifstream.


Key display format
------------------

Keys are displayed by default in base 58 encoding. This can be changed to be
base 16 or base 32. Base 58 encoding produces upper and lower case letters
and numbers. Most programs consider a base 58 encoded string as a single
word, allowing easy selection and copying. Base 16 is the normal hexadecimal
dump of the key. Base 32 produces an encoding with only letters and digits
and is not case sensitive.

Whichever encoding is selected the key always contains the 32 bytes of the
key plus an additional byte of CRC. This CRC byte is also encoded with the
key. The purpose of the additional CRC byte is to catch mistakes when the key
is typed by humans and not read from files.



Archive storage format
----------------------

The archive format is inspired by the ZIP format, although it is much
simpler. The file is made of TLV triplets in Protocol Buffers format. The big
picture is that each file is stored (optionally compressed) sequentially in
the file. After the files there is a central directory. The central directory
is made of a sequence of directory entries. After the central directory there
is a 64-bit little endian integer that contains the offset of the start of the
central directory relative to the beginning of the file. This structure is
the same as a ZIP file: it allows sequential processing from the beginning
and also random access to each file using the central directory. The
difference is that instead of using ZIP's own format, we use the protocol
buffers' wire format.

There is a triplet that contains a flag, `pack_flag`. If its bit 0 is set then
the files in this archive are compressed. If bit 0 is clear then the files
are not compressed. The algorithm used to compress is *deflate*. The flag is
written as a triplet with *maketag(pack_flag, varint)*.

The files are written sequentially and include the name and mode of each
file. Each file is compressed separately, allowing for extraction of each
file independently from others. Each file is a triplet with
maketag(pack_file, group_len). This triplet contains the followig triplets:

 - the triplet maketag(tag_name, length_val) contains the name of the file.

 - the triplet maketag(tag_mode, varint) contains the mode bits of the file.
   This is the st_mode field of struct stat.

 - the triplet maketag(tag_mtime, varint) contais the modification time of
   the file or directory in microseconds.

 - the triplet maketag(tag_content, length_val) contains the contents of the
   file. If the pack_flag has bit 0 set then these are the compressed
   contents of the file.

After the sequence of files we note the current position of the file. This is
the start of the central directory. We first write again the
maketag(pack_flag,varint) triplet. Then we start the
maketag(pack_dir,group_len) group. Within this group we have a triplet for
each of the files. This triplet has the tag maketag(pack_item,group_len).
Within the pack_item triplet we have the following triplets:

 - maketag(tag_pos,varint) contains the position of the contents of the file
   within the packed archive.

 - maketag(tag_compsz,varint) contains the size in bytes of the compressed
   stream.

 - maketag(tag_expsz,varint) contains the original size of the file before
   compression.

 - maketag(tag_mode,varint) contains the mode bits of the file. This is
   identical to the st_mode field of struct stat.

 - maketag(tag_mtime,varint) contains the modification time of the file in
   microseconds since the epoch.

 - maketag(tag_name,length_val) contains the name of the file.

The last triplet in the file is a maketag(pack_last,fixed64) which contains a
little endian 8 byte value with the position of the start of the central
directory in the packed archive.

Note that the packing and unpacking routines known nothing about encryption.
They just use an encrypting `ofstream` and a decrypting `ifstream`. We
describe here the contents of the unencrypted packed file.

When a file should be extracted, the unpacking program will first seek to the
end of the file and read the 8 bytes that store the offset of the central
directory. Then it shall read the flag and the central directory. Once that
the selected file has been identified in the central directory the item
corresponding to that file provides the information required to extract it:
the compressed file is stored starting at the offset `item_pos` and has
`item_compsz` bytes.



Signature Format
================

Signatures are computed by first hashing the input data with Blake2b. If there
is an optional comment then the comment is appended to the hash input after
the data. The resulting hash is then signed using `cu25519_sign()`. The
signature file is written either in binary format or its equivalent base 64
encoding.

The binary format is made of a triplet maketag(sig_group,group_len). This
triplet contains the following triplets:

 - maketag(sig_signer,length_val) contains the 32 bytes of the signer's
   public key.

 - maketag(sig_signature,length_val) contains the 64 byte of the signature.

 - maketag(sig_comment,length_val) contains the comments attached to the
   signature. This triplet is optional.

The following triplets are optionally include in the sig_group triplet if the
`--add-certs` option was given.

 - maketag(sig_name,length_val) contains the name of the signer.

 - maketag(sig_ctime,fixed64) contains the creation time of the signing key.

 - maketag(sig_self,length_val) contains the signature of the signing key by
   the signing key itself.

 - maketag(sig_cert,group_len) contains a signature of the signing key by
   somebody else. This triplet is optional and may be repeated as many times
   as required. This triplet contains the following triplets:

	- maketag(sig_signer,length_val) contains the 32 bytes of the certifying
	  public key.

	- maketag(sig_signature,length_val) contains the 64 bytes of the certificate.

When the program verifies a signature it checks that both the data and
comment can be verified with the signature (sig_signature) and the key of
the signer (sig_signer). If the signature is correct then the program will
try to find the public key of the signer in the public key ring and output
the name of the signer. If the signer could not be found and certificates are
present the program will output the name of the signer as stated in the
signature and then each certificate will be checked to see if they are valid.
If the certificate is valid then the certificate's signer will be shown too.

A typical case for adding certificates to a signature is if we sign with a
working key. We add the certificate by the corresponding master key. When
verifying the signature we may have the signer's master key in our key ring,
but not the working key used to sign (perhaps it expired long ago). In this
case we state that the key is unverified but was signed by the master key. It
is up to the user to decide what to do with such a signature. If it is a
document that was signed long ago we may accept the signature. If it is a
signature that should be recent we may reject signatures that have not been
produced with a current working key.

Note that if certificates are present they will also be part of the input to
the cu25519_sign() function. This is required to detect any tampering with
the signature itself.

