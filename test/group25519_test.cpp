/*
 * Copyright (c) 2015-2018, Pelayo Bernedo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "group25519.hpp"
#include "misc.hpp"
#include "hasopt.hpp"
#include <iostream>
#include <string.h>
#include <fstream>
#include <iomanip>
#include <assert.h>

using namespace amber;

// Vectors from https://tools.ietf.org/html/draft-irtf-cfrg-curves-05
void test_x25519()
{
	std::cout << "Testing X25519 vectors.\n";
	// Alice's private key, f:
	const char asec[] = "77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a";
	// Alice's public key, X25519(f, 9):
	const char apub[] = "8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a";
	// Bob's private key, g:
	const char bsec[] = "5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb";
	// Bob's public key, X25519(g, 9):
	const char bpub[] = "de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f";
	// Their shared secret, K:
	const char shared[] = "4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742";

	Cu25519Sec as, bs;
	Cu25519Mon ap, bp, rap, rbp;
	std::vector<uint8_t> tmp;
	const char *last;

	read_block (asec, &last, tmp);
	if (*last || tmp.size() != 32) {
		std::cout << "error reading key\n";
		return;
	}
	memcpy (as.b, &tmp[0], 32);

	read_block (bsec, &last, tmp);
	if (*last || tmp.size() != 32) {
		std::cout << "error reading key\n";
		return;
	}
	memcpy (bs.b, &tmp[0], 32);

	read_block (apub, &last, tmp);
	if (*last || tmp.size() != 32) {
		std::cout << "error reading key\n";
		return;
	}
	memcpy (rap.b, &tmp[0], 32);

	read_block (bpub, &last, tmp);
	if (*last || tmp.size() != 32) {
		std::cout << "error reading key\n";
		return;
	}
	memcpy (rbp.b, &tmp[0], 32);

	read_block (shared, &last, tmp);
	if (*last || tmp.size() != 32) {
		std::cout << "error reading key\n";
		return;
	}

	cu25519_generate (&as, &ap);
	ap.b[31] &= 0x7F;
	if (crypto_neq (ap.b, rap.b, 32)) {
		std::cout << "Error in generating the public key 1\n";
		show_block (std::cout, "scalar  ", as.b, 32);
		show_block (std::cout, "computed", ap.b, 32);
		show_block (std::cout, "expected", rap.b, 32);
		return;
	}
	cu25519_generate (&bs, &bp);
	bp.b[31] &= 0x7F;
	if (crypto_neq (bp.b, rbp.b, 32)) {
		std::cout << "Error in generating the public key 2\n";
		show_block (std::cout, "scalar  ", bs.b, 32);
		show_block (std::cout, "computed", bp.b, 32);
		show_block (std::cout, "expected", rbp.b, 32);
		return;
	}
	uint8_t sh[32];
	cu25519_shared_secret (sh, ap, bs);
	if (crypto_neq (sh, &tmp[0], 32)) {
		std::cout << "error in shared key\n";
		show_block (std::cout, "computed", sh, 32);
		show_block (std::cout, "expected", &tmp[0], 32);
		return;
	}
	cu25519_shared_secret (sh, bp, as);
	if (crypto_neq (sh, &tmp[0], 32)) {
		std::cout << "error in shared key\n";
		show_block (std::cout, "computed", sh, 32);
		show_block (std::cout, "expected", &tmp[0], 32);
		return;
	}
	std::cout << "X25519 vectors tested.\n";
}



struct Test_case {
	const char *sec, *pub, *msg, *sig;
};


static const Test_case ietf[] = {

{   // SECRET KEY:
	"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60",
	// PUBLIC KEY:
	"d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a",
	// MESSAGE (length 0 bytes):
	"",
	// SIGNATURE:
	"e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e06522490155"
	"5fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b"
},
{
	// SECRET KEY:
	"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb",
	// PUBLIC KEY:
	"3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c",
	// MESSAGE (length 1 byte):
	"72",
	// SIGNATURE:
	"92a009a9f0d4cab8720e820b5f642540a2b27b5416503f8fb3762223ebdb69da"
	"085ac1e43e15996e458f3613d0f11d8c387b2eaeb4302aeeb00d291612bb0c00"
},
{
	// SECRET KEY:
	"c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7",
	// PUBLIC KEY:
	"fc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025",
	// MESSAGE (length 2 bytes):
	"af82",
	// SIGNATURE:
	"6291d657deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac3ac"
	"18ff9b538d16f290ae67f760984dc6594a7c15e9716ed28dc027beceea1ec40a"
}

};

void test_ed25519 (const Test_case *tc, size_t n)
{
	std::vector<uint8_t> tmp, msg;
	const char *next;

	std::cout << "Testing " << n << " IETF Ed25519 test vectors.\n";

	while (n > 0) {
		uint8_t seed[32], ey[32], eygood[32];
		read_block (tc->sec, &next, tmp);
		if (*next) {
			std::cout << "Error reading the secret key.\n";
			return;
		}
		if (tmp.size() != 32) {
			std::cout << "The key must be 32 bytes long. Got " << tmp.size() << ".\n";
			return;
		}
		memcpy (seed, &tmp[0], tmp.size());

		read_block (tc->pub, &next, tmp);
		if (*next) {
			std::cout << "Error reading the public key.\n";
			return;
		}
		if (tmp.size() != 32) {
			std::cout << "The key must be 32 bytes long. Got " << tmp.size() << ".\n";
			return;
		}
		memcpy (eygood, &tmp[0], tmp.size());

		ed25519_seed_to_ey (ey, seed);

		if (crypto_neq (ey, eygood, 32)) {
			std::cout << "Error in the computed public Ed25519 key.\n";
			show_block (std::cout, "computed", ey, 32);
			show_block (std::cout, "good    ", eygood, 32);
			return;
		}

		read_block (tc->msg, &next, tmp);
		if (*next) {
			std::cout << "Error reading the message.\n";
			return;
		}
		msg = std::move (tmp);

		read_block (tc->sig, &next, tmp);
		if (*next) {
			std::cout << "Error reading the signature.\n";
			return;
		}
		if (tmp.size() != 64) {
			std::cout << "The signature must be 64 bytes long. Got " << tmp.size() << ".\n";;
			return;
		}

		uint8_t mysig[64];
		sign_sey (&msg[0], msg.size(), ey, seed, mysig);

		if (crypto_neq (mysig, &tmp[0], 64)) {
			std::cout << "The signature is wrong.\n";
			return;
		}
		if (0 != verify_sey (&msg[0], msg.size(), mysig, ey)) {
			std::cout << "The verication with ey failed.\n";
			return;
		}

		--n;
		++tc;
	}
	std::cout << "All Ed25519 tests finished.\n";
}


void show_const()
{
	static const Fe feone = { 1 };
	std::cout << "\nConstants used in the program\n";
	Fe x, y, z, sqrt_m1;
	memset (x.v, 0, sizeof x);
	x.v[0] = 2;
	raise_253_5 (y, x);
	std::cout << "sqrt(-1) = 2^(2²⁵³ - 5) =" << y << '\n';
	show_raw ("sqrt(-1) raw", y);
	sqrt_m1 = y;
	x.v[0] = 486664;
	negate (x, x);
	if (sqrt(z, x) == 0) {
		std::cout << "C = sqrt(-A-2): " << z << '\n';
		show_raw ("C = sqrt(-A-2), raw", z);
	}

	// d = -121665/121666
	x.v[0] = 121665;
	negate (y, x);
	x.v[0] = 121666;
	invert (z, x);
	mul (y, y, z);
	Fe d = y;
	std::cout << "d: " << y << '\n';
	show_raw ("d raw", y);
	add (y, y, y);
	show_raw ("2d raw", y);

	std::cout << "\nConstants of the ristretto paper\n";
	Fe u;
	sub (u, d, feone);
	square (u, u);
	std::cout << "(d - 1)²=" << u << "  (called d_minus_one_sq)\n";
	show_raw ("d_minus_one_sq", u);
	square (u, d);
	sub (u, feone, u);
	std::cout << "1 - d²=" << u << "  (called one_minus_d_sq) \n";
	show_raw ("one_minus_d_sq", u);
	add (u, d, feone);
	negate (u, u);
	invsqrt (u, u);
	std::cout << "invsqrt(a - d)=" << u << "  (called invsqrt_a_minus_d)\n";
	show_raw ("invsqrt_a_minus_d", u);
	add (u, d, feone);
	negate (u, u);
	sqrt (u, u);
	std::cout << "sqrt(-1 - d)=" << u << '\n';
	negate (u, u);
	std::cout << "sqrt(-1 - d)=" << u << "  (called sqrt_ad_minus_one)\n";
	show_raw ("sqrt_ad_minus_one", u);

	uint8_t bu[32] = { 9 };
	Edwards e;
	mxs_to_edwards (e, bu, false);
	std::cout << "basepoint in Edwards:\n";
	// Normalize to z = 1.
	invert (y, e.z);
	mul (e.x, e.x, y);
	mul (e.y, e.y, y);
	memset (e.z.v, 0, sizeof(Fe));
	e.z.v[0] = 1;
	mul (e.t, e.x, e.y);
	show_raw ("b.x", e.x);
	show_raw ("b.y", e.y);
	show_raw ("b.z", e.z);
	show_raw ("b.t", e.t);

	uint8_t sc[32];
	memset (sc, 0, 32);
	sc[31] = 0x40;
	scalarbase (e, sc);
	pdouble (e, e);
	pdouble (e, e);
	std::cout << "Base point times 2^256\n";
	show_raw ("bm.x", e.x);
	show_raw ("bm.y", e.y);
	show_raw ("bm.z", e.z);
	show_raw ("bm.t", e.t);
}



void test_scalarmult()
{
	Cu25519Sec xs;
	Cu25519Mon xp;
	randombytes_buf (xs.b, 32);
	cu25519_generate (&xs, &xp);

	Edwards e1;
	uint8_t mx[32];

	scalarbase (e1, xs.b);
	edwards_to_mxs (mx, e1);
	if (memcmp (xp.b, mx, 32) != 0) {
		format (std::cout, "Error in scalarbase().\n");
	}
	scalarmult (e1, edwards_base_point, xs.b);
	edwards_to_mxs (mx, e1);
	if (memcmp (xp.b, mx, 32) != 0) {
		format (std::cout, "Error in scalarmult().\n");
	}
	scalarmult_fw (e1, edwards_base_point, xs.b);
	edwards_to_mxs (mx, e1);
	if (memcmp (xp.b, mx, 32) != 0) {
		format (std::cout, "Error in scalarmult_fw().\n");
	}

	montgomery_base (e1, xs.b);
	edwards_to_mxs (mx, e1);
	if (memcmp (xp.b, mx, 32) != 0) {
		format (std::cout, "Error in montgomery_base(Edwards).\n");
	}
	montgomery_base (mx, xs.b);
	if (memcmp (xp.b, mx, 32) != 0) {
		format (std::cout, "Error in montgomery_base(mx).\n");
	}
	montgomery_ladder (e1, edwards_base_point, xs.b);
	edwards_to_mxs (mx, e1);
	if (memcmp (xp.b, mx, 32) != 0) {
		format (std::cout, "Error in montgomery_ladder(Edwards).\n");
	}

	format (std::cout, "Scalar multiplication tested.\n");
}


void test_conv()
{
	uint8_t sc[32];
	Edwards e1, e2;

	randombytes_buf (sc, 32);
	mask_scalar(sc);
	scalarbase (e1, sc);

	Fe u, v;
	static const Fe feone = { 1 };
	edwards_to_mont (u, v, e1);
	mont_to_edwards (e2, u, v, feone);

	uint8_t ey1[32], ey2[32];
	edwards_to_eys (ey1, e1);
	edwards_to_eys (ey2, e2);
	if (memcmp (ey1, ey2, 32) != 0) {
		format (std::cout, "Error in edwards/mont conversions.\n");
	}
}


void test_curvesig()
{
	Cu25519Sec xs;
	Cu25519Mon xp;
	randombytes_buf (xs.b, 32);
	cu25519_generate (&xs, &xp);

	uint8_t sig[64];
	curvesig ("Amber sig", xs.b, 32, xp.b, xs.b, sig);
	int errc = curverify ("Amber sig", xs.b, 32, sig, xp.b);
	format (std::cout, "curverify returns %d\n", errc);
	errc = curverify_mont ("Amber sig", xs.b, 32, sig, xp.b);
	format (std::cout, "curverify_mont returns %d\n", errc);

	uint8_t nsig[64];
	memcpy (nsig, sig, 32);
	negate_scalar (nsig + 32, sig + 32);
	errc = curverify_mont ("Amber sig", xs.b, 32, nsig, xp.b);
	format (std::cout, "curverify_mont with nsig returns %d\n", errc);
	errc = curverify ("Amber sig", xs.b, 32, sig, xp.b);
	format (std::cout, "curverify returns %d\n", errc);
}


// Encoding of base multiples from 0 to 15.
static const uint8_t ristretto_vectors[][32] = {
   { 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
   { 0xe2, 0xf2, 0xae, 0x0a, 0x6a, 0xbc, 0x4e, 0x71, 0xa8, 0x84, 0xa9, 0x61, 0xc5, 0000, 0x51, 0x5f, 0x58, 0xe3, 0x0b, 0x6a, 0xa5, 0x82, 0xdd, 0x8d, 0xb6, 0xa6, 0x59, 0x45, 0xe0, 0x8d, 0x2d, 0x76 },
   { 0x6a, 0x49, 0x32, 0x10, 0xf7, 0x49, 0x9c, 0xd1, 0x7f, 0xec, 0xb5, 0x10, 0xae, 0x0c, 0xea, 0x23, 0xa1, 0x10, 0xe8, 0xd5, 0xb9, 0x01, 0xf8, 0xac, 0xad, 0xd3, 0x09, 0x5c, 0x73, 0xa3, 0xb9, 0x19 },
   { 0x94, 0x74, 0x1f, 0x5d, 0x5d, 0x52, 0x75, 0x5e, 0xce, 0x4f, 0x23, 0xf0, 0x44, 0xee, 0x27, 0xd5, 0xd1, 0xea, 0x1e, 0x2b, 0xd1, 0x96, 0xb4, 0x62, 0x16, 0x6b, 0x16, 0x15, 0x2a, 0x9d, 0x02, 0x59 },
   { 0xda, 0x80, 0x86, 0x27, 0x73, 0x35, 0x8b, 0x46, 0x6f, 0xfa, 0xdf, 0xe0, 0xb3, 0x29, 0x3a, 0xb3, 0xd9, 0xfd, 0x53, 0xc5, 0xea, 0x6c, 0x95, 0x53, 0x58, 0xf5, 0x68, 0x32, 0x2d, 0xaf, 0x6a, 0x57 },
   { 0xe8, 0x82, 0xb1, 0x31, 0x01, 0x6b, 0x52, 0xc1, 0xd3, 0x33, 0x70, 0x80, 0x18, 0x7c, 0xf7, 0x68, 0x42, 0x3e, 0xfc, 0xcb, 0xb5, 0x17, 0xbb, 0x49, 0x5a, 0xb8, 0x12, 0xc4, 0x16, 0x0f, 0xf4, 0x4e },
   { 0xf6, 0x47, 0x46, 0xd3, 0xc9, 0x2b, 0x13, 0x05, 0x0e, 0xd8, 0xd8, 0x02, 0x36, 0xa7, 0xf0, 0000, 0x7c, 0x3b, 0x3f, 0x96, 0x2f, 0x5b, 0xa7, 0x93, 0xd1, 0x9a, 0x60, 0x1e, 0xbb, 0x1d, 0xf4, 0x03 },
   { 0x44, 0xf5, 0x35, 0x20, 0x92, 0x6e, 0xc8, 0x1f, 0xbd, 0x5a, 0x38, 0x78, 0x45, 0xbe, 0xb7, 0xdf, 0x85, 0xa9, 0x6a, 0x24, 0xec, 0xe1, 0x87, 0x38, 0xbd, 0xcf, 0xa6, 0xa7, 0x82, 0x2a, 0x17, 0x6d },
   { 0x90, 0x32, 0x93, 0xd8, 0xf2, 0x28, 0x7e, 0xbe, 0x10, 0xe2, 0x37, 0x4d, 0xc1, 0xa5, 0x3e, 0x0b, 0xc8, 0x87, 0xe5, 0x92, 0x69, 0x9f, 0x02, 0xd0, 0x77, 0xd5, 0x26, 0x3c, 0xdd, 0x55, 0x60, 0x1c },
   { 0x02, 0x62, 0x2a, 0xce, 0x8f, 0x73, 0x03, 0xa3, 0x1c, 0xaf, 0xc6, 0x3f, 0x8f, 0xc4, 0x8f, 0xdc, 0x16, 0xe1, 0xc8, 0xc8, 0xd2, 0x34, 0xb2, 0xf0, 0xd6, 0x68, 0x52, 0x82, 0xa9, 0x07, 0x60, 0x31 },
   { 0x20, 0x70, 0x6f, 0xd7, 0x88, 0xb2, 0x72, 0x0a, 0x1e, 0xd2, 0xa5, 0xda, 0xd4, 0x95, 0x2b, 0x01, 0xf4, 0x13, 0xbc, 0xf0, 0xe7, 0x56, 0x4d, 0xe8, 0xcd, 0xc8, 0x16, 0x68, 0x9e, 0x2d, 0xb9, 0x5f },
   { 0xbc, 0xe8, 0x3f, 0x8b, 0xa5, 0xdd, 0x2f, 0xa5, 0x72, 0x86, 0x4c, 0x24, 0xba, 0x18, 0x10, 0xf9, 0x52, 0x2b, 0xc6, 0000, 0x4a, 0xfe, 0x95, 0x87, 0x7a, 0xc7, 0x32, 0x41, 0xca, 0xfd, 0xab, 0x42 },
   { 0xe4, 0x54, 0x9e, 0xe1, 0x6b, 0x9a, 0xa0, 0x30, 0x99, 0xca, 0x20, 0x8c, 0x67, 0xad, 0xaf, 0xca, 0xfa, 0x4c, 0x3f, 0x3e, 0x4e, 0x53, 0x03, 0xde, 0x60, 0x26, 0xe3, 0xca, 0x8f, 0xf8, 0x44, 0x60 },
   { 0xaa, 0x52, 0xe0, 0000, 0xdf, 0x2e, 0x16, 0xf5, 0x5f, 0xb1, 0x03, 0x2f, 0xc3, 0x3b, 0xc4, 0x27, 0x42, 0xda, 0xd6, 0xbd, 0x5a, 0x8f, 0xc0, 0xbe, 0x01, 0x67, 0x43, 0x6c, 0x59, 0x48, 0x50, 0x1f },
   { 0x46, 0x37, 0x6b, 0x80, 0xf4, 0x09, 0xb2, 0x9d, 0xc2, 0xb5, 0xf6, 0xf0, 0xc5, 0x25, 0x91, 0x99, 0x08, 0x96, 0xe5, 0x71, 0x6f, 0x41, 0x47, 0x7c, 0xd3, 0000, 0x85, 0xab, 0x7f, 0x10, 0x30, 0x1e },
   { 0xe0, 0xc4, 0x18, 0xf7, 0xc8, 0xd9, 0xc4, 0xcd, 0xd7, 0x39, 0x5b, 0x93, 0xea, 0x12, 0x4f, 0x3a, 0xd9, 0x90, 0x21, 0xbb, 0x68, 0x1d, 0xfc, 0x33, 0x02, 0xa9, 0xd9, 0x9a, 0x2e, 0x53, 0xe6, 0x4e }
};

struct Uni_case {
	uint8_t in[64];
	uint8_t out[32];
};

static const Uni_case unicase[] = {
	{
	  { 0x5d, 0x1b, 0xe0, 0x9e, 0x3d, 0x0c, 0x82, 0xfc, 0x53, 0x81, 0x12, 0x49, 0x0e, 0x35, 0x70, 0x19, 0x79, 0xd9, 0x9e, 0x06, 0xca, 0x3e, 0x2b, 0x5b, 0x54, 0xbf, 0xfe, 0x8b, 0x4d, 0xc7, 0x72, 0xc1, 0x4d, 0x98, 0xb6, 0x96, 0xa1, 0xbb, 0xfb, 0x5c, 0xa3, 0x2c, 0x43, 0x6c, 0xc6, 0x1c, 0x16, 0x56, 0x37, 0x90, 0x30, 0x6c, 0x79, 0xea, 0xca, 0x77, 0x05, 0x66, 0x8b, 0x47, 0xdf, 0xfe, 0x5b, 0xb6 },
	  { 0x30, 0x66, 0xf8, 0x2a, 0x1a, 0x74, 0x7d, 0x45, 0x12, 0x0d, 0x17, 0x40, 0xf1, 0x43, 0x58, 0x53, 0x1a, 0x8f, 0x04, 0xbb, 0xff, 0xe6, 0xa8, 0x19, 0xf8, 0x6d, 0xfe, 0x50, 0xf4, 0x4a, 0x0a, 0x46 }
	},
	{
	  { 0xf1, 0x16, 0xb3, 0x4b, 0x8f, 0x17, 0xce, 0xb5, 0x6e, 0x87, 0x32, 0xa6, 0x0d, 0x91, 0x3d, 0xd1, 0x0c, 0xce, 0x47, 0xa6, 0xd5, 0x3b, 0xee, 0x92, 0x04, 0xbe, 0x8b, 0x44, 0xf6, 0x67, 0x8b, 0x27, 0x01, 0x02, 0xa5, 0x69, 0x02, 0xe2, 0x48, 0x8c, 0x46, 0x12, 0x0e, 0x92, 0x76, 0xcf, 0xe5, 0x46, 0x38, 0x28, 0x6b, 0x9e, 0x4b, 0x3c, 0xdb, 0x47, 0x0b, 0x54, 0x2d, 0x46, 0xc2, 0x06, 0x8d, 0x38 },
	  { 0xf2, 0x6e, 0x5b, 0x6f, 0x7d, 0x36, 0x2d, 0x2d, 0x2a, 0x94, 0xc5, 0xd0, 0xe7, 0x60, 0x2c, 0xb4, 0x77, 0x3c, 0x95, 0xa2, 0xe5, 0xc3, 0x1a, 0x64, 0xf1, 0x33, 0x18, 0x9f, 0xa7, 0x6e, 0xd6, 0x1b }
	},
	{
	  { 0x84, 0x22, 0xe1, 0xbb, 0xda, 0xab, 0x52, 0x93, 0x8b, 0x81, 0xfd, 0x60, 0x2e, 0xff, 0xb6, 0xf8, 0x91, 0x10, 0xe1, 0xe5, 0x72, 0x08, 0xad, 0x12, 0xd9, 0xad, 0x76, 0x7e, 0x2e, 0x25, 0x51, 0x0c, 0x27, 0x14, 0x07, 0x75, 0xf9, 0x33, 0x70, 0x88, 0xb9, 0x82, 0xd8, 0x3d, 0x7f, 0xcf, 0x0b, 0x2f, 0xa1, 0xed, 0xff, 0xe5, 0x19, 0x52, 0xcb, 0xe7, 0x36, 0x5e, 0x95, 0xc8, 0x6e, 0xaf, 0x32, 0x5c },
	  { 0x00, 0x6c, 0xcd, 0x2a, 0x9e, 0x68, 0x67, 0xe6, 0xa2, 0xc5, 0xce, 0xa8, 0x3d, 0x33, 0x02, 0xcc, 0x9d, 0xe1, 0x28, 0xdd, 0x2a, 0x9a, 0x57, 0xdd, 0x8e, 0xe7, 0xb9, 0xd7, 0xff, 0xe0, 0x28, 0x26 }
	},
	{
	  { 0xac, 0x22, 0x41, 0x51, 0x29, 0xb6, 0x14, 0x27, 0xbf, 0x46, 0x4e, 0x17, 0xba, 0xee, 0x8d, 0xb6, 0x59, 0x40, 0xc2, 0x33, 0xb9, 0x8a, 0xfc, 0xe8, 0xd1, 0x7c, 0x57, 0xbe, 0xeb, 0x78, 0x76, 0xc2, 0x15, 0x0d, 0x15, 0xaf, 0x1c, 0xb1, 0xfb, 0x82, 0x4b, 0xbd, 0x14, 0x95, 0x5f, 0x2b, 0x57, 0xd0, 0x8d, 0x38, 0x8a, 0xab, 0x43, 0x1a, 0x39, 0x1c, 0xfc, 0x33, 0xd5, 0xba, 0xfb, 0x5d, 0xbb, 0xaf },
	  { 0xf8, 0xf0, 0xc8, 0x7c, 0xf2, 0x37, 0x95, 0x3c, 0x58, 0x90, 0xae, 0xc3, 0x99, 0x81, 0x69, 0x00, 0x5d, 0xae, 0x3e, 0xca, 0x1f, 0xbb, 0x04, 0x54, 0x8c, 0x63, 0x59, 0x53, 0xc8, 0x17, 0xf9, 0x2a }
	},
	{
	  { 0x16, 0x5d, 0x69, 0x7a, 0x1e, 0xf3, 0xd5, 0xcf, 0x3c, 0x38, 0x56, 0x5b, 0xee, 0xfc, 0xf8, 0x8c, 0x0f, 0x28, 0x2b, 0x8e, 0x7d, 0xbd, 0x28, 0x54, 0x4c, 0x48, 0x34, 0x32, 0xf1, 0xce, 0xc7, 0x67, 0x5d, 0xeb, 0xea, 0x8e, 0xbb, 0x4e, 0x5f, 0xe7, 0xd6, 0xf6, 0xe5, 0xdb, 0x15, 0xf1, 0x55, 0x87, 0xac, 0x4d, 0x4d, 0x4a, 0x1d, 0xe7, 0x19, 0x1e, 0x0c, 0x1c, 0xa6, 0x66, 0x4a, 0xbc, 0xc4, 0x13 },
	  { 0xae, 0x81, 0xe7, 0xde, 0xdf, 0x20, 0xa4, 0x97, 0xe1, 0x0c, 0x30, 0x4a, 0x76, 0x5c, 0x17, 0x67, 0xa4, 0x2d, 0x6e, 0x06, 0x02, 0x97, 0x58, 0xd2, 0xd7, 0xe8, 0xef, 0x7c, 0xc4, 0xc4, 0x11, 0x79 }
	},
	{
	  { 0xa8, 0x36, 0xe6, 0xc9, 0xa9, 0xca, 0x9f, 0x1e, 0x8d, 0x48, 0x62, 0x73, 0xad, 0x56, 0xa7, 0x8c, 0x70, 0xcf, 0x18, 0xf0, 0xce, 0x10, 0xab, 0xb1, 0xc7, 0x17, 0x2d, 0xdd, 0x60, 0x5d, 0x7f, 0xd2, 0x97, 0x98, 0x54, 0xf4, 0x7a, 0xe1, 0xcc, 0xf2, 0x04, 0xa3, 0x31, 0x02, 0x09, 0x5b, 0x42, 0x00, 0xe5, 0xbe, 0xfc, 0x04, 0x65, 0xac, 0xcc, 0x26, 0x31, 0x75, 0x48, 0x5f, 0x0e, 0x17, 0xea, 0x5c },
	  { 0xe2, 0x70, 0x56, 0x52, 0xff, 0x9f, 0x5e, 0x44, 0xd3, 0xe8, 0x41, 0xbf, 0x1c, 0x25, 0x1c, 0xf7, 0xdd, 0xdb, 0x77, 0xd1, 0x40, 0x87, 0x0d, 0x1a, 0xb2, 0xed, 0x64, 0xf1, 0xa9, 0xce, 0x86, 0x28 }
	},
	{
	   { 0x2c, 0xdc, 0x11, 0xea, 0xeb, 0x95, 0xda, 0xf0, 0x11, 0x89, 0x41, 0x7c, 0xdd, 0xdb, 0xf9, 0x59, 0x52, 0x99, 0x3a, 0xa9, 0xcb, 0x9c, 0x64, 0x0e, 0xb5, 0x05, 0x8d, 0x09, 0x70, 0x2c, 0x74, 0x62, 0x2c, 0x99, 0x65, 0xa6, 0x97, 0xa3, 0xb3, 0x45, 0xec, 0x24, 0xee, 0x56, 0x33, 0x5b, 0x55, 0x6e, 0x67, 0x7b, 0x30, 0xe6, 0xf9, 0x0a, 0xc7, 0x7d, 0x78, 0x10, 0x64, 0xf8, 0x66, 0xa3, 0xc9, 0x82 },
	   { 0x80, 0xbd, 0x07, 0x26, 0x25, 0x11, 0xcd, 0xde, 0x48, 0x63, 0xf8, 0xa7, 0x43, 0x4c, 0xef, 0x69, 0x67, 0x50, 0x68, 0x1c, 0xb9, 0x51, 0x0e, 0xea, 0x55, 0x70, 0x88, 0xf7, 0x6d, 0x9e, 0x50, 0x65 }
	}
};


static const uint8_t bad_ristretto[][32] = {
   { 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
   { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
   { 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
   { 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
   { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
   { 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
   { 0xed, 0x57, 0xff, 0xd8, 0xc9, 0x14, 0xfb, 0x20, 0x14, 0x71, 0xd1, 0xc3, 0xd2, 0x45, 0xce, 0x3c, 0x74, 0x6f, 0xcb, 0xe6, 0x3a, 0x36, 0x79, 0xd5, 0x1b, 0x6a, 0x51, 0x6e, 0xbe, 0xbe, 0x0e, 0x20},
   { 0xc3, 0x4c, 0x4e, 0x18, 0x26, 0xe5, 0xd4, 0x03, 0xb7, 0x8e, 0x24, 0x6e, 0x88, 0xaa, 0x05, 0x1c, 0x36, 0xcc, 0xf0, 0xaa, 0xfe, 0xbf, 0xfe, 0x13, 0x7d, 0x14, 0x8a, 0x2b, 0xf9, 0x10, 0x45, 0x62},
   { 0xc9, 0x40, 0xe5, 0xa4, 0x40, 0x41, 0x57, 0xcf, 0xb1, 0x62, 0x8b, 0x10, 0x8d, 0xb0, 0x51, 0xa8, 0xd4, 0x39, 0xe1, 0xa4, 0x21, 0x39, 0x4e, 0xc4, 0xeb, 0xcc, 0xb9, 0xec, 0x92, 0xa8, 0xac, 0x78},
   { 0x47, 0xcf, 0xc5, 0x49, 0x7c, 0x53, 0xdc, 0x8e, 0x61, 0xc9, 0x1d, 0x17, 0xfd, 0x62, 0x6f, 0xfb, 0x1c, 0x49, 0xe2, 0xbc, 0xa9, 0x4e, 0xed, 0x05, 0x22, 0x81, 0xb5, 0x10, 0xb1, 0x11, 0x7a, 0x24},
   { 0xf1, 0xc6, 0x16, 0x5d, 0x33, 0x36, 0x73, 0x51, 0xb0, 0xda, 0x8f, 0x6e, 0x45, 0x11, 0x01, 0x0c, 0x68, 0x17, 0x4a, 0x03, 0xb6, 0x58, 0x12, 0x12, 0xc7, 0x1c, 0x0e, 0x1d, 0x02, 0x6c, 0x3c, 0x72},
   { 0x87, 0x26, 0x0f, 0x7a, 0x2f, 0x12, 0x49, 0x51, 0x18, 0x36, 0x0f, 0x02, 0xc2, 0x6a, 0x47, 0x0f, 0x45, 0x0d, 0xad, 0xf3, 0x4a, 0x41, 0x3d, 0x21, 0x04, 0x2b, 0x43, 0xb9, 0xd9, 0x3e, 0x13, 0x09},
   { 0x26, 0x94, 0x8d, 0x35, 0xca, 0x62, 0xe6, 0x43, 0xe2, 0x6a, 0x83, 0x17, 0x73, 0x32, 0xe6, 0xb6, 0xaf, 0xeb, 0x9d, 0x08, 0xe4, 0x26, 0x8b, 0x65, 0x0f, 0x1f, 0x5b, 0xbd, 0x8d, 0x81, 0xd3, 0x71},
   { 0x4e, 0xac, 0x07, 0x7a, 0x71, 0x3c, 0x57, 0xb4, 0xf4, 0x39, 0x76, 0x29, 0xa4, 0x14, 0x59, 0x82, 0xc6, 0x61, 0xf4, 0x80, 0x44, 0xdd, 0x3f, 0x96, 0x42, 0x7d, 0x40, 0xb1, 0x47, 0xd9, 0x74, 0x2f},
   { 0xde, 0x6a, 0x7b, 0x00, 0xde, 0xad, 0xc7, 0x88, 0xeb, 0x6b, 0x6c, 0x8d, 0x20, 0xc0, 0xae, 0x96, 0xc2, 0xf2, 0x01, 0x90, 0x78, 0xfa, 0x60, 0x4f, 0xee, 0x5b, 0x87, 0xd6, 0xe9, 0x89, 0xad, 0x7b},
   { 0xbc, 0xab, 0x47, 0x7b, 0xe2, 0x08, 0x61, 0xe0, 0x1e, 0x4a, 0x0e, 0x29, 0x52, 0x84, 0x14, 0x6a, 0x51, 0x01, 0x50, 0xd9, 0x81, 0x77, 0x63, 0xca, 0xf1, 0xa6, 0xf4, 0xb4, 0x22, 0xd6, 0x70, 0x42},
   { 0x2a, 0x29, 0x2d, 0xf7, 0xe3, 0x2c, 0xab, 0xab, 0xbd, 0x9d, 0xe0, 0x88, 0xd1, 0xd1, 0xab, 0xec, 0x9f, 0xc0, 0x44, 0x0f, 0x63, 0x7e, 0xd2, 0xfb, 0xa1, 0x45, 0x09, 0x4d, 0xc1, 0x4b, 0xea, 0x08},
   { 0xf4, 0xa9, 0xe5, 0x34, 0xfc, 0x0d, 0x21, 0x6c, 0x44, 0xb2, 0x18, 0xfa, 0x0c, 0x42, 0xd9, 0x96, 0x35, 0xa0, 0x12, 0x7e, 0xe2, 0xe5, 0x3c, 0x71, 0x2f, 0x70, 0x60, 0x96, 0x49, 0xfd, 0xff, 0x22},
   { 0x82, 0x68, 0x43, 0x6f, 0x8c, 0x41, 0x26, 0x19, 0x6c, 0xf6, 0x4b, 0x3c, 0x7d, 0xdb, 0xda, 0x90, 0x74, 0x6a, 0x37, 0x86, 0x25, 0xf9, 0x81, 0x3d, 0xd9, 0xb8, 0x45, 0x70, 0x77, 0x25, 0x67, 0x31},
   { 0x28, 0x10, 0xe5, 0xcb, 0xc2, 0xcc, 0x4d, 0x4e, 0xec, 0xe5, 0x4f, 0x61, 0xc6, 0xf6, 0x97, 0x58, 0xe2, 0x89, 0xaa, 0x7a, 0xb4, 0x40, 0xb3, 0xcb, 0xea, 0xa2, 0x19, 0x95, 0xc2, 0xf4, 0x23, 0x2b},
   { 0x3e, 0xb8, 0x58, 0xe7, 0x8f, 0x5a, 0x72, 0x54, 0xd8, 0xc9, 0x73, 0x11, 0x74, 0xa9, 0x4f, 0x76, 0x75, 0x5f, 0xd3, 0x94, 0x1c, 0x0a, 0xc9, 0x37, 0x35, 0xc0, 0x7b, 0xa1, 0x45, 0x79, 0x63, 0x0e},
   { 0xa4, 0x5f, 0xdc, 0x55, 0xc7, 0x64, 0x48, 0xc0, 0x49, 0xa1, 0xab, 0x33, 0xf1, 0x70, 0x23, 0xed, 0xfb, 0x2b, 0xe3, 0x58, 0x1e, 0x9c, 0x7a, 0xad, 0xe8, 0xa6, 0x12, 0x52, 0x15, 0xe0, 0x42, 0x20},
   { 0xd4, 0x83, 0xfe, 0x81, 0x3c, 0x6b, 0xa6, 0x47, 0xeb, 0xbf, 0xd3, 0xec, 0x41, 0xad, 0xca, 0x1c, 0x61, 0x30, 0xc2, 0xbe, 0xee, 0xe9, 0xd9, 0xbf, 0x06, 0x5c, 0x8d, 0x15, 0x1c, 0x5f, 0x39, 0x6e},
   { 0x8a, 0x2e, 0x1d, 0x30, 0x05, 0x01, 0x98, 0xc6, 0x5a, 0x54, 0x48, 0x31, 0x23, 0x96, 0x0c, 0xcc, 0x38, 0xae, 0xf6, 0x84, 0x8e, 0x1e, 0xc8, 0xf5, 0xf7, 0x80, 0xe8, 0x52, 0x37, 0x69, 0xba, 0x32},
   { 0x32, 0x88, 0x84, 0x62, 0xf8, 0xb4, 0x86, 0xc6, 0x8a, 0xd7, 0xdd, 0x96, 0x10, 0xbe, 0x51, 0x92, 0xbb, 0xea, 0xf3, 0xb4, 0x43, 0x95, 0x1a, 0xc1, 0xa8, 0x11, 0x84, 0x19, 0xd9, 0xfa, 0x09, 0x7b},
   { 0x22, 0x71, 0x42, 0x50, 0x1b, 0x9d, 0x43, 0x55, 0xcc, 0xba, 0x29, 0x04, 0x04, 0xbd, 0xe4, 0x15, 0x75, 0xb0, 0x37, 0x69, 0x3c, 0xef, 0x1f, 0x43, 0x8c, 0x47, 0xf8, 0xfb, 0xf3, 0x5d, 0x11, 0x65},
   { 0x5c, 0x37, 0xcc, 0x49, 0x1d, 0xa8, 0x47, 0xcf, 0xeb, 0x92, 0x81, 0xd4, 0x07, 0xef, 0xc4, 0x1e, 0x15, 0x14, 0x4c, 0x87, 0x6e, 0x01, 0x70, 0xb4, 0x99, 0xa9, 0x6a, 0x22, 0xed, 0x31, 0xe0, 0x1e},
   { 0x44, 0x54, 0x25, 0x11, 0x7c, 0xb8, 0xc9, 0x0e, 0xdc, 0xbc, 0x7c, 0x1c, 0xc0, 0xe7, 0x4f, 0x74, 0x7f, 0x2c, 0x1e, 0xfa, 0x56, 0x30, 0xa9, 0x67, 0xc6, 0x4f, 0x28, 0x77, 0x92, 0xa4, 0x8a, 0x4b},
   { 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f}
};

inline bool equal (const Fe &fe1, const Fe &fe2)
{
	Fe diff;
	sub (diff, fe1, fe2);
	return ct_is_zero (diff);
}

void test_ristretto (int count)
{
	Edwards p1, p2;
	uint8_t sc[32], rs[32];

	for (int i = 0; i < count; ++i) {
		randombytes_buf (sc, 32);
		scalarbase (p1, sc);

		edwards_to_ristretto (rs, p1);
		int errc = ristretto_to_edwards (p2, rs);

		if (errc != 0 || !ristretto_equal (p1, p2)) {
			format (std::cout, "ristretto errc=%d\n", errc);
			std::cout << "p1: " << p1 << '\n';
			std::cout << "p2: " << p2 << '\n';
		}

		uint8_t rs2[32];
		edwards_to_ristretto (rs2, p2);
		if (memcmp (rs, rs2, 32) != 0) {
			format (std::cout, "Wrong reencoding\n");
		}
		Edwards p22;
		ristretto_to_edwards (p22, rs2);
		uint8_t ey1[32], ey2[32];
		edwards_to_eys (ey1, p2);
		edwards_to_eys (ey2, p22);
		if (memcmp (ey1, ey2, 32) != 0) {
			format (std::cout, "Wrong redecoding\n");
		}

		Edwards p3;
		Fe u1, v1;
		errc = ristretto_to_mont (p3, u1, v1, rs);
		if (errc != 0 || !equal (p3.x, p2.x) || !equal(p3.y, p2.y)) {
			format (std::cout, "ristretto_to_mont failed, errc=%d\n", errc);
			format (std::cout, "p2.y=%s\np3.y=%s\n", p2.y, p3.y);
			format (std::cout, "p2.x=%s\np3.x=%s\n", p2.x, p3.x);
		}
		Fe u2, v2;
		edwards_to_mont (u2, v2, p3);
		if (!equal (u1, u2) || !equal(v1, v2)) {
			format (std::cout, "Wrong mont conversion\n");
			format (std::cout, "u1=%s\nu2=%s\nv1=%s\nv2=%s\n", u1, u2, v1, v2);
			Fe nv1;
			negate (nv1, v1);
			format (std::cout, "-v1=%s\n", nv1);
		}
	}
	format (std::cout, "ristretto encode and decode checked on %d random points\n",  count);

	memset (sc, 0, 32);
	for (int i = 0; i < 16; ++i) {
		sc[0] = i;
		scalarbase (p1, sc);
		edwards_to_ristretto (rs, p1);
		if (memcmp (rs, ristretto_vectors[i], 32) != 0) {
			format (std::cout, "B[%2d]    ", i);
			show_block (std::cout, " ", rs, 32);
			format (std::cout, " expected");
			show_block (std::cout, " ", ristretto_vectors[i], 32);
		}
		int errc = ristretto_to_edwards (p2, rs);
		int eq = ristretto_equal (p1, p2);
		if (errc != 0 || !eq) {
			format (std::cout, "in B[%d], decoder: %d,  eq=%d\n", i, errc, eq);
		}
	}
	format (std::cout, "Checked the ristretto base multiples 0-15\n");

	for (size_t i = 0; i < sizeof(unicase)/sizeof(unicase[0]); ++i) {
		ristretto_from_uniform (p1, unicase[i].in);
		edwards_to_ristretto (rs, p1);
		if (memcmp (rs, unicase[i].out, 32) != 0) {
			format (std::cout, "Error in uniform item %d\n", i);
		}
	}
	format (std::cout, "Checked ristretto_from_uniform %d test vectors\n", sizeof(unicase)/sizeof(unicase[0]));

	enum { nbad = sizeof(bad_ristretto)/sizeof(bad_ristretto[0]) };
	for (int i = 0; i < nbad; ++i) {
		Edwards p;
		int errc = ristretto_to_edwards (p, bad_ristretto[i]);
		if (errc == 0) {
			format (std::cout, "The bad point %d was accepted!\n", i);
		}
	}
	format (std::cout, "Checked detection of %d bad points.\n", nbad);
}


void test_ristretto_sign (int count)
{
	uint8_t sig[64];
	Cu25519Sec rss;
	Cu25519Ris rsp;

	for (int i = 0; i < count; ++i) {
		randombytes_buf (rss.b, 32);
		cu25519_generate_no_mask (rss, &rsp);
		cu25519_sign ("ristretto", rss.b, 32, rsp, rss, sig);
		int errc = cu25519_verify ("ristretto", rss.b, 32, sig, rsp);
		if (errc != 0) {
			format (std::cout, "cu25519_verify failed\n");
		}
		errc = ristretto_qdsa_verify ("ristretto", rss.b, 32, sig, rsp);
		if (errc != 0) {
			format (std::cout, "error in ristretto_qdsa_verify\n");
		}
	}
	format (std::cout, "Checked %d ristretto signatures\n", count);
}


#if 1

// List of points with no contributory behaviour from the Curve25519 paper.
// The last 5 points have bit 255 set. This bit is automatically cleared by
// the curve25519_expand() routine.
static uint8_t small_order_mx[][32] = {
	{ 0 },              // 0
	{ 0x1 },            // 1
	// x1
	{ 0xe0, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae,
	  0x16, 0x56, 0xe3, 0xfa, 0xf1, 0x9f, 0xc4, 0x6a,
	  0xda, 0x9, 0x8d, 0xeb, 0x9c, 0x32, 0xb1, 0xfd,
	  0x86, 0x62, 0x5, 0x16, 0x5f, 0x49, 0xb8 },
	// x2
	{ 0x5f, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24,
	  0xb1, 0xd0, 0xb1, 0x55, 0x9c, 0x83, 0xef, 0x5b,
	  0x4, 0x44, 0x5c, 0xc4, 0x58, 0x1c, 0x8e, 0x86,
	  0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0x57, },
	// 2²⁵⁵ - 19 - 1
	{ 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, },
	// 2²⁵⁵ - 19
	{ 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, },
	// 2²⁵⁵ - 19 + 1
	{ 0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, },
	// 2²⁵⁵ - 19 + x1
	{ 0xcd, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae,
	  0x16, 0x56, 0xe3, 0xfa, 0xf1, 0x9f, 0xc4, 0x6a,
	  0xda, 0x9, 0x8d, 0xeb, 0x9c, 0x32, 0xb1, 0xfd,
	  0x86, 0x62, 0x5, 0x16, 0x5f, 0x49, 0xb8, 0x80, },
	// 2²⁵⁵ - 19 + x2
	{ 0x4c, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24,
	  0xb1, 0xd0, 0xb1, 0x55, 0x9c, 0x83, 0xef, 0x5b,
	  0x4, 0x44, 0x5c, 0xc4, 0x58, 0x1c, 0x8e, 0x86,
	  0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0xd7, },
	// 2*(2²⁵⁵ - 19) - 1
	{ 0xd9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, },
	// 2*(2²⁵⁵ - 19)
	{ 0xda, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, },
	// 2*(2²⁵⁵ - 19) + 1
	{ 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, }
};
#endif


void small_ris()
{
	enum { nsmall = sizeof(small_order_mx)/sizeof(small_order_mx[0]) };
	for (int i = 0; i < nsmall; ++i) {
		Edwards p;
		if (mxs_to_edwards (p, small_order_mx[i], false) != 0) {
			format (std::cout, "mxs_to_edwards failed for point %d\n", i);
			continue;
		}
		uint8_t rs[32];
		edwards_to_ristretto (rs, p);
		Edwards p2;
		if (ristretto_to_edwards (p2, rs) != 0) {
			format (std::cout, "r_to_e failed for point %d\n", i);
			show_block (std::cout, "rs", rs, 32);
		}
	}
}


void test_ristretto_ladder()
{
	// Order - 1.
	static const uint8_t L1[32] = { 0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12,
	                                 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9,
	                                 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	                                 0, 0, 0, 0, 0x10};

	Cu25519Sec sc1, sc2;
	Cu25519Ris rs1, rs2;
	Cu25519Mon mx1, mx2;
	Edwards p1, p2;
	uint8_t lad1[32], lad2[32], lad3[32], lad4[32];
	int nwrong = 0;
	enum { ladder_tests = 1000 };
	for (int i = 0; i < ladder_tests; ++i) {
		randombytes_buf (sc1.b, 32);
		randombytes_buf (sc2.b, 32);
		if (i == 0) {
			memcpy (sc1.b, L1, 32);
		}
		// Check for any scalar, not just the masked ones.
		scalarbase (p1, sc1.b);
		scalarbase (p2, sc2.b);
		edwards_to_ristretto (rs1.b, p1);
		edwards_to_ristretto (rs2.b, p2);
		edwards_to_mxs (mx1.b, p1);
		edwards_to_mxs (mx2.b, p2);
		int errc1 = cu25519_shared_secret_cof_checked (lad1, rs1, sc2);
		int errc2 = cu25519_shared_secret_cof_checked (lad2, rs2, sc1);
		if (errc1 != 0 || errc2 != 0) {
			format (std::cout, "Error in risladder\n");
		}
		if (crypto_neq (lad1, lad2, 32)) {
			nwrong++;
		}

		// Check that the ladder outputs from Ristretto and Montgomery inputs
		// are the same.
		mask_scalar (sc1.b);
		mask_scalar (sc2.b);
		scalarbase (p1, sc1.b);
		scalarbase (p2, sc2.b);
		edwards_to_ristretto (rs1.b, p1);
		edwards_to_ristretto (rs2.b, p2);
		edwards_to_mxs (mx1.b, p1);
		edwards_to_mxs (mx2.b, p2);
		errc1 = cu25519_shared_secret_checked (lad1, rs1, sc2);
		errc2 = cu25519_shared_secret_checked (lad2, rs2, sc1);
		int errc3 = cu25519_shared_secret_checked (lad3, mx1, sc2);
		int errc4 = cu25519_shared_secret_checked (lad4, mx2, sc1);
		if (errc1 != 0 || errc2 != 0) {
			format (std::cout, "Error in risladder\n");
		}
		if (errc3 != 0 || errc4 != 0) {
			format (std::cout, "Error in mont ladder\n");
		}
		if (crypto_neq (lad1, lad2, 32) || crypto_neq (lad1, lad3, 32) || crypto_neq (lad1, lad4, 32)) {
			nwrong++;
		}
	}
	format (std::cout, "Checking ristretto_ladders, %d wrong out of %d cases\n", nwrong, ladder_tests);
}



void test_sqrt_m1 (int count)
{
	static const Fe feone = { 1 };
	static const Fe fezero = { 0 };
	Fe root;
	int err = sqrt_ratio_m1 (root, feone, feone);
	format (std::cout, "err=%d  root(1/1)=%s\n", err, root);
	err = sqrt_ratio_m1 (root, fezero, feone);
	format (std::cout, "err=%d  root(0/1)=%s\n", err, root);
	err = sqrt_ratio_m1 (root, feone, fezero);
	format (std::cout, "err=%d  root(1/0)=%s\n", err, root);
	err = sqrt_ratio_m1 (root, fezero, fezero);
	format (std::cout, "err=%d  root(0/0)=%s\n", err, root);
	err = invsqrt (root, fezero);
	format (std::cout, "err=%d  invsqrt(0)=%s\n", err, root);

	for (int i = 0; i < count; ++i) {
		uint8_t sc[32];
		randombytes_buf (sc, 32);
		Fe x, xii1, xii2;
		load (x, sc);
		int sq1 = !!invsqrt (xii1, x);
		int sq2 = !!sqrt_ratio_m1 (xii2, feone, x);
		if (sq1 != sq2) {
			std::cout << "sqrt ratio differs\n";
			format (std::cout, "xii1=%s\nxii2=%s\n", xii1, xii2);
		}
	}
}

enum { A = 486662 };

bool is_in_curve (const Fe &u)
{
	// v² = u³+Au²+u
	Fe u2, v2;
	square (u2, u);
	mul_small (v2, u2, A);
	add (v2, v2, u);
	mul (u2, u2, u);
	add (v2, v2, u2);
	return sqrt (u2, v2) == 0;
}


void test_curve_point (int count)
{
	for (int i = 0; i < count; ++i) {
		uint8_t s[32], u[32];
		randombytes_buf (s, 32);
		mask_scalar (s);
		Fe fu, fmu, fmz;
		load (fu, s);
		montgomery_ladder (fmu, fmz, fu, s);

		Edwards ep;
		reduce_store (u, fu);
		bool is_point = mxs_to_edwards (ep, u, false) == 0;
		bool is_i_curve = is_in_curve (fu);
		assert (is_point == is_i_curve);

		Fe zu, isr, mu;
		mul (zu, fmu, fmz);
		bool is_sqr = invsqrt (isr, zu) == 0;
		invert (mu, fmz);
		mul (mu, mu, fmu);
		bool is_m_curve = is_in_curve (mu);

		assert (is_point == is_sqr);
		assert (is_i_curve == is_m_curve);
	}
	format (std::cout, "%d points tested for twist and small order rejection\n", count);
}


int main()
{
	test_ristretto(200);
	test_ristretto_sign(100);
	test_ristretto_ladder();
	test_curvesig();
	test_x25519();
	test_ed25519 (ietf, sizeof(ietf)/sizeof(ietf[0]));
	show_const();
	write_summands ("summands.txt");
	test_conv();
	test_scalarmult();
	test_sqrt_m1(5);
	test_curve_point (1000);
}

